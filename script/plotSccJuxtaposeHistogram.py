# This script is used to plot the complexity or complexity/code from two input files. 
# The input files are generated by the `scc` tool and contain the complexity and complexity/code for each file in the project. 
# The script reads the input files, extracts the data, and plots the complexity or complexity/code for each file in a histogram. 
# The files are sorted based on the complexity or complexity/code from the first input file, 
# and the corresponding values from the second input file are aligned accordingly.

# first argument: complexity or complexity/code
# second argument: chatgpt output file
# third argument: human output file
# Examples:
# python3 script_name.py complexity scc_chatgpt.txt scc_human.txt
# python3 script_name.py complexity/code scc_chatgpt.txt scc_human.txt

import matplotlib.pyplot as plt
import numpy as np
import argparse

# Function to parse the input text
def parse_input(input_text):
    entries = [x.strip() for x in input_text.split("----------------------------------------------------------------------------------------------------------------------------------------------------------------")]
    file_data = []

    for entry in entries:
        if "Processing" in entry:
            lines = entry.splitlines()
            file_name = lines[0].split("Processing ")[1].split("...")[0].strip()
            for line in lines:
                if line.strip().startswith("Total"):
                    parts = line.split()
                    code = int(parts[-2])
                    complexity = int(parts[-1])
                    complexity_per_code = round (complexity / code, 2)
                    file_data.append((file_name, complexity, complexity_per_code))
    return file_data

# Function to plot the data
def plot_data(file_data1, file_data2, metric):
    # Sort the first file data by the selected metric
    if metric == 'complexity':
        file_data1.sort(key=lambda x: x[1])
        y1_index = 1
    elif metric == 'complexity/code':
        file_data1.sort(key=lambda x: x[2])
        y1_index = 2
    
    # Prepare data for plotting
    file_names1 = [data[0] for data in file_data1]
    y1_values = [data[y1_index] for data in file_data1]

    # Create a dictionary for the second file data for easy lookup
    file_data2_dict = {data[0]: data[y1_index] for data in file_data2}

    # Align the second file data to the sorted file names of the first file
    y2_values = [file_data2_dict.get(file_name, 0) for file_name in file_names1]

    # Plotting the histograms
    x = np.arange(len(file_names1))
    width = 0.4

    fig, ax = plt.subplots(figsize=(14, 8))  # Width: 14, Height: 8

    # Plotting the selected metric for both files as histograms
    rects1 = ax.bar(x - width/2, y1_values, width, color='royalblue', label='ChatGPT')
    rects2 = ax.bar(x + width/2, y2_values, width, color='sandybrown', label='Human')

    # Add labels, title, and custom x-axis tick labels
    ax.set_xlabel('File Names')
    ax.set_ylabel(metric.capitalize())
    ax.set_title(f'{metric.capitalize()} by file (sorted based on ChatGPT)')
    ax.set_xticks(x)
    ax.set_xticklabels(file_names1, rotation=45, ha='right')
    ax.legend(loc='upper left')

    # Add values on top of the bars
    def autolabel(rects):
        for rect in rects:
            height = rect.get_height()
            ax.annotate('{}'.format(height),
                        xy=(rect.get_x() + rect.get_width() / 2, height),
                        xytext=(0, 3),  # 3 points vertical offset
                        textcoords="offset points",
                        ha='center', va='bottom')

    autolabel(rects1)
    autolabel(rects2)

    fig.tight_layout()
    plt.show()

# Main function to handle arguments and plot
def main():
    parser = argparse.ArgumentParser(description='Plot complexity or complexity/code from two input files.')
    parser.add_argument('metric', choices=['complexity', 'complexity/code'], help='Metric to plot: complexity or complexity/code')
    parser.add_argument('input1', help='First input file')
    parser.add_argument('input2', help='Second input file')

    args = parser.parse_args()

    # Read the input from the first file
    with open(args.input1, 'r') as file1:
        input_text1 = file1.read()

    # Read the input from the second file
    with open(args.input2, 'r') as file2:
        input_text2 = file2.read()

    # Extract data from the input texts
    file_data1 = parse_input(input_text1)
    file_data2 = parse_input(input_text2)

    # Plot the data based on the selected metric
    plot_data(file_data1, file_data2, args.metric)

if __name__ == "__main__":
    main()
